name: Release Management

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type'
        required: true
        default: 'auto'
        type: choice
        options:
          - auto
          - major
          - feat
          - fix
          - docs
          - chore
          - refactor

permissions:
  contents: write
  pull-requests: read

jobs:
  preview:
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    outputs:
      should_release: ${{ steps.analysis.outputs.should_release }}
      release_type: ${{ steps.analysis.outputs.release_type }}
      version_tag: ${{ steps.analysis.outputs.version_tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Extract commit message safely
        id: msg
        shell: bash
        run: |
          set -euo pipefail
          # Pull title or head commit message from the event payload safely via jq.
          COMMIT_MSG="$(jq -r '
            .pull_request.title //                       # PR title if PR event
            .head_commit.message //                      # push event single commit
            .commits[-1].message //                      # last commit on push with multiple commits
            .workflow_run.head_commit.message //         # fallback for workflow_run dispatches
            empty
          ' "$GITHUB_EVENT_PATH")"

          # Guard: ensure we extracted something
          if [[ -z "${COMMIT_MSG:-}" ]]; then
            echo "‚úñ Could not extract commit message from $GITHUB_EVENT_PATH" >&2
            jq . "$GITHUB_EVENT_PATH" | head -n 120
            exit 1
          fi

          # Export to the environment via heredoc; this preserves all special chars.
          {
            echo 'COMMIT_MSG<<__MSG__'
            printf '%s\n' "$COMMIT_MSG"
            echo '__MSG__'
          } >> "$GITHUB_ENV"

          echo "üìù Commit message extracted:"
          printf '%s\n' "$COMMIT_MSG"

      - name: Analyze commit for release preview
        id: analysis
        shell: bash
        run: |
          set -euo pipefail
          echo "üìã **Release Preview Analysis**"
          echo ""
          echo "üîç **Commit:** \`$COMMIT_MSG\`"
          
          # Use shared patterns for analysis
          RESULT=$(node .github/scripts/release-patterns.mjs "$COMMIT_MSG")
          
          echo "üìä **Pattern Analysis:**"
          echo "\`\`\`json"
          echo "$RESULT" | jq '.'
          echo "\`\`\`"
          
          # Extract values
          RELEASE_TYPE=$(echo "$RESULT" | jq -r '.releaseType')
          VERSION_TAG=$(echo "$RESULT" | jq -r '.versionTag') 
          TRIGGERS_RELEASE=$(echo "$RESULT" | jq -r '.triggersRelease')
          HAS_CODEPEN=$(echo "$RESULT" | jq -r '.hasCodePen')
          
          echo ""
          if [ "$TRIGGERS_RELEASE" = "true" ]; then
            echo "‚úÖ **Would create release:** \`$VERSION_TAG\` (type: $RELEASE_TYPE)"
          else
            echo "‚è≠Ô∏è **No release:** commit type \`$RELEASE_TYPE\` doesn't trigger releases"
          fi
          
          if [ "$HAS_CODEPEN" = "true" ]; then
            echo "üé® **CodePen mention detected:** Release notes will include CodePen showcase section"
          fi
          
          # Set outputs for dependent job
          echo "should_release=$TRIGGERS_RELEASE" >> $GITHUB_OUTPUT
          echo "release_type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
          echo "version_tag=$VERSION_TAG" >> $GITHUB_OUTPUT

  release:
    runs-on: ubuntu-latest
    needs: [preview]
    if: (github.event_name == 'push' && needs.preview.outputs.should_release == 'true') || github.event_name == 'workflow_dispatch'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Extract commit message safely
        id: msg
        shell: bash
        run: |
          set -euo pipefail
          # Pull title or head commit message from the event payload safely via jq.
          COMMIT_MSG="$(jq -r '
            .pull_request.title //                       # PR title if PR event
            .head_commit.message //                      # push event single commit
            .commits[-1].message //                      # last commit on push with multiple commits
            .workflow_run.head_commit.message //         # fallback for workflow_run dispatches
            empty
          ' "$GITHUB_EVENT_PATH")"

          # Guard: ensure we extracted something
          if [[ -z "${COMMIT_MSG:-}" ]]; then
            echo "‚úñ Could not extract commit message from $GITHUB_EVENT_PATH" >&2
            jq . "$GITHUB_EVENT_PATH" | head -n 120
            exit 1
          fi

          # Export to the environment via heredoc; this preserves all special chars.
          {
            echo 'COMMIT_MSG<<__MSG__'
            printf '%s\n' "$COMMIT_MSG"
            echo '__MSG__'
          } >> "$GITHUB_ENV"

          echo "üìù Commit message extracted:"
          printf '%s\n' "$COMMIT_MSG"

      - name: Debug commit message
        shell: bash
        run: |
          set -euo pipefail
          echo "üìù Commit message received:"
          printf '%.120s\n' "$COMMIT_MSG"
          echo "üìä Event type: ${{ github.event_name }}"

      - name: Quote torture test (debug only)
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          torture='feat(footer): match CodePen "Neon Facebook Hover"; magnetic hover + sparkles (#21)'
          {
            echo 'TEST_MSG<<__MSG__'
            printf '%s\n' "$torture"
            echo '__MSG__'
          } >> "$GITHUB_ENV"
          printf 'OK: %q\n' "$TEST_MSG" || true
          
      - name: Determine release type
        id: release_type
        shell: bash
        run: |
          set -euo pipefail
          echo "üîç Analyzing commit: $(printf '%.80s' "$COMMIT_MSG")"
          
          # Determine release type from commit message or workflow input using shared patterns
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.release_type }}" != "auto" ]; then
            RELEASE_TYPE="${{ github.event.inputs.release_type }}"
          else
            # Use shared release patterns module for consistent logic
            RESULT=$(node .github/scripts/release-patterns.mjs "$COMMIT_MSG")
            RELEASE_TYPE=$(echo "$RESULT" | node -e "console.log(JSON.parse(require('fs').readFileSync(0)).releaseType)")
            echo "üìä Pattern analysis: $RESULT"
          fi
          echo "release_type=$RELEASE_TYPE" >> $GITHUB_OUTPUT

      - name: Generate version tag
        id: version
        shell: bash
        run: |
          set -euo pipefail
          RELEASE_TYPE="${{ steps.release_type.outputs.release_type }}"
          
          # Generate version using shared patterns module
          RESULT=$(node .github/scripts/release-patterns.mjs "$COMMIT_MSG")
          BASE_VERSION=$(echo "$RESULT" | node -e "console.log(JSON.parse(require('fs').readFileSync(0)).versionTag)")
          DATE=$(date -u +%Y.%m.%d)
          
          echo "üìÖ Base version: $BASE_VERSION"
          
          # If tag exists, append sequence number
          VERSION="$BASE_VERSION"
          if git tag -l "$VERSION" | grep -q "$VERSION"; then
            COUNTER=1
            while git tag -l "${VERSION}.${COUNTER}" | grep -q "${VERSION}.${COUNTER}"; do
              COUNTER=$((COUNTER + 1))
            done
            VERSION="${VERSION}.${COUNTER}"
            echo "üî¢ Incremented to: $VERSION"
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "date=$DATE" >> $GITHUB_OUTPUT

      - name: Check if release needed
        id: should_release
        shell: bash
        run: |
          set -euo pipefail
          # Check if this is a meaningful commit for release using shared patterns
          RELEASE_TYPE="${{ steps.release_type.outputs.release_type }}"
          
          # Skip releases for certain commit types unless manually triggered
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "should_release=true" >> $GITHUB_OUTPUT
          else
            # Use shared patterns to determine if this should trigger a release
            RESULT=$(node .github/scripts/release-patterns.mjs "$COMMIT_MSG")
            TRIGGERS_RELEASE=$(echo "$RESULT" | node -e "console.log(JSON.parse(require('fs').readFileSync(0)).triggersRelease)")
            
            if [ "$TRIGGERS_RELEASE" = "true" ]; then
              echo "should_release=true" >> $GITHUB_OUTPUT
              echo "‚úÖ Release triggered by commit type: $RELEASE_TYPE"
            else
              echo "should_release=false" >> $GITHUB_OUTPUT
              echo "‚è≠Ô∏è Skipping release for commit type: $RELEASE_TYPE"
            fi
          fi

      - name: Generate release notes
        id: release_notes
        if: steps.should_release.outputs.should_release == 'true'
        run: |
          # Get the previous tag
          PREV_TAG=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "")
          CURRENT_TAG="${{ steps.version.outputs.version }}"
          
          # Generate release notes
          cat << 'EOF' > release_notes.md
          ## What's Changed
          
          EOF
          
          if [ -n "$PREV_TAG" ]; then
            echo "### Commits since $PREV_TAG" >> release_notes.md
            echo "" >> release_notes.md
            
            # Get commits since last tag, grouped by type
            git log ${PREV_TAG}..HEAD --oneline --pretty=format:"- %s (%h)" | \
            while read -r line; do
              if [[ "$line" =~ ^-\ feat(\(.*\))?:\ (.*) ]]; then
                echo "**‚ú® Features:** $line" >> release_notes.md
              elif [[ "$line" =~ ^-\ fix(\(.*\))?:\ (.*) ]]; then
                echo "**üêõ Bug Fixes:** $line" >> release_notes.md
              elif [[ "$line" =~ ^-\ docs(\(.*\))?:\ (.*) ]]; then
                echo "**üìù Documentation:** $line" >> release_notes.md
              elif [[ "$line" =~ ^-\ chore(\(.*\))?:\ (.*) ]]; then
                echo "**üßπ Maintenance:** $line" >> release_notes.md
              elif [[ "$line" =~ ^-\ refactor(\(.*\))?:\ (.*) ]]; then
                echo "**‚ôªÔ∏è Refactoring:** $line" >> release_notes.md
              elif [[ "$line" =~ ^-\ perf(\(.*\))?:\ (.*) ]]; then
                echo "**‚ö° Performance:** $line" >> release_notes.md
              elif [[ "$line" =~ ^-\ ci(\(.*\))?:\ (.*) ]]; then
                echo "**üîß CI/CD:** $line" >> release_notes.md
              else
                echo "**üì¶ Other:** $line" >> release_notes.md
              fi
            done
          else
            echo "### Initial Release" >> release_notes.md
            echo "" >> release_notes.md
            echo "- Initial VIPSpot release with comprehensive portfolio and contact pipeline" >> release_notes.md
          fi
          
          # Check if CodePen is mentioned in commit messages using shared patterns
          RESULT=$(node .github/scripts/release-patterns.mjs "$COMMIT_MSG")
          HAS_CODEPEN=$(echo "$RESULT" | node -e "console.log(JSON.parse(require('fs').readFileSync(0)).hasCodePen)")
          
          if [ "$HAS_CODEPEN" = "true" ]; then
            echo "" >> release_notes.md
            echo "### üé® CodePen Updates" >> release_notes.md
            echo "This release includes CodePen-related changes! Check out our demos:" >> release_notes.md
            echo "- **CodePen Profile:** https://codepen.io/CoderRvrse" >> release_notes.md
            echo "- **Featured Demos:** See README.md for latest showcases" >> release_notes.md
            printf 'CodePen mention detected in: %s\n' "$COMMIT_MSG"
          fi
          
          echo "" >> release_notes.md
          echo "### üîó Links" >> release_notes.md
          echo "- **Live Site:** https://vipspot.net" >> release_notes.md
          echo "- **API Health:** https://vipspot-api-a7ce781e1397.herokuapp.com/healthz" >> release_notes.md
          echo "- **Documentation:** https://github.com/CoderRvrse/vipspot#readme" >> release_notes.md
          
          # Set output
          echo "notes_file=release_notes.md" >> $GITHUB_OUTPUT

      - name: Update CHANGELOG.md
        if: steps.should_release.outputs.should_release == 'true'
        shell: bash
        run: |
          set -euo pipefail
          VERSION="${{ steps.version.outputs.version }}"
          DATE="${{ steps.version.outputs.date }}"
          
          # Create temporary changelog entry with CodePen enhancement
          cat << EOF > changelog_entry.md
          ## [${VERSION#v}] - $(date -u +%Y-%m-%d)
          
          ### Changed
          - $COMMIT_MSG
          
          EOF
          
          # Add CodePen showcase section to changelog if detected
          RESULT=$(node .github/scripts/release-patterns.mjs "$COMMIT_MSG")
          HAS_CODEPEN=$(echo "$RESULT" | node -e "console.log(JSON.parse(require('fs').readFileSync(0)).hasCodePen)")
          
          if [ "$HAS_CODEPEN" = "true" ]; then
            cat << EOF >> changelog_entry.md
          ### üé® CodePen Showcase
          This release includes CodePen-related enhancements:
          - **Rocket Back-to-Top** ‚Üí [Demo](https://codepen.io/CoderRvrse/pen/QwjXGom)
          - **3D Card Hover Effect** ‚Üí [Demo](https://codepen.io/CoderRvrse/pen/VYvNzzN)
          - **Matrix Rain Effect** ‚Üí [Demo](https://codepen.io/CoderRvrse/pen/azvxEZG)
          - **Browse All Demos** ‚Üí [CodePen Profile](https://codepen.io/CoderRvrse)
          
          EOF
          fi
          
          # Insert new entry after [Unreleased] section
          if [ -f CHANGELOG.md ]; then
            # Create new changelog with updated entry
            awk '
              /^## \[Unreleased\]/ { 
                print; 
                while ((getline line) > 0 && line !~ /^## \[/) {
                  print line;
                }
                system("cat changelog_entry.md");
                if (line ~ /^## \[/) print line;
                next;
              }
              { print }
            ' CHANGELOG.md > CHANGELOG_new.md
            mv CHANGELOG_new.md CHANGELOG.md
            
            # Update the links section
            sed -i "s|\[Unreleased\]: .*|\[Unreleased\]: https://github.com/CoderRvrse/vipspot/compare/${VERSION}...HEAD|" CHANGELOG.md
            echo "[${VERSION#v}]: https://github.com/CoderRvrse/vipspot/releases/tag/${VERSION}" >> CHANGELOG.md
          fi
          
          rm -f changelog_entry.md

      - name: Commit changelog updates
        if: steps.should_release.outputs.should_release == 'true'
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          if [ -n "$(git status --porcelain CHANGELOG.md)" ]; then
            git add CHANGELOG.md
            git commit -m "chore(release): update CHANGELOG for ${VERSION}"
            git push
          fi

      - name: Create Release
        if: steps.should_release.outputs.should_release == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.version.outputs.version }}
          name: 'Release ${{ steps.version.outputs.version }}'
          body_path: ${{ steps.release_notes.outputs.notes_file }}
          draft: false
          prerelease: false
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Summary
        if: steps.should_release.outputs.should_release == 'true'
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          echo "üéâ Released $VERSION"
          echo "üìù Release notes generated from commit history"
          echo "üìã CHANGELOG.md updated"
          echo "üîó Release: https://github.com/CoderRvrse/vipspot/releases/tag/$VERSION"